/**
 * Genome Parser Unit Tests
 *
 * Tests all supported file formats:
 * - 23andMe (v3, v4, v5)
 * - AncestryDNA
 * - MyHeritage
 * - FamilyTreeDNA
 * - LivingDNA
 * - VCF
 *
 * @packageDocumentation
 */

import { describe, it, expect, beforeEach } from 'vitest';
import {
  parseGenomeFile,
  detectFormat,
  detectBuild,
  getChromosomeCounts,
  getNoCallRate,
  getHeterozygosityRate,
  GenomeParseError
} from '../index';
import { parse23andMeLine, detect23andMeVersion, is23andMeFormat } from '../23andme';
import { parseAncestryLine, isAncestryFormat } from '../ancestry';
import { parseMyHeritageLine, isMyHeritageFormat } from '../myheritage';
import { parseFTDNALine, isFTDNAFormat } from '../ftdna';
import { parseLivingDNALine, isLivingDNAFormat } from '../livingdna';
import { parseVCFLine, isVCFFormat, detectVCFVersion, getVCFSampleNames } from '../vcf';
import { normalizeChromosome, validateGenotype, isValidRsid } from '../utils';
import type { SNP, Chromosome } from '@genomeforge/types';

// ============================================================================
// Sample Data - 23andMe Format
// ============================================================================

const SAMPLE_23ANDME_V5 = `# This data file generated by 23andMe at: Tue Oct 01 12:00:00 2024
#
# This file contains raw genotype data, including data that is not used in 23andMe reports.
# This data has undergone a general quality review however only a subset of markers have been
# individually validated for accuracy. As such, this data is suitable only for research,
# educational, and informational use and not for medical or other use.
#
# Below is a text version of your data.  Fields are TAB-separated
# Each line corresponds to a single SNP.  For each SNP, we provide its identifier
# (an rsid or an internal id), its location on the reference human genome, and the
# genotype call oriented with respect to the plus strand on the human reference sequence.
# We are using reference human assembly build 37 (also known as Annotation Release 104).
# Note that it is possible that data downloaded at different times may be different due to
# ongoing improvements in our ability to call genotypes. More information about these
# changes can be found at:
# https://www.23andme.com/you/download/revisions/
#
# More information on reference human assembly builds:
# https://www.ncbi.nlm.nih.gov/assembly/GCF_000001405.13/
#
# rsid	chromosome	position	genotype
rs4477212	1	82154	AA
rs3094315	1	752566	AG
rs3131972	1	752721	AG
rs12184267	1	764319	CC
rs12562034	1	768448	GG
rs4040617	1	779322	AG
rs2980300	1	790533	TT
rs4970383	1	838555	AA
rs4475691	1	846808	CC
rs7537756	1	854250	AG
rs13302982	1	871896	GG
rs6681049	1	1185051	CC
rs4422948	1	1199346	AA
rs2286533	1	1205055	CT
rs10796689	1	1214376	AA
rs7526076	1	1227566	CC
rs12564807	1	1231872	AA
rs1891910	1	1238638	GG
rs78444831	X	2781976	AA
rs2032597	Y	14795628	CC
rs2853826	MT	2706	AG
i713426	1	72017	--
`;

const SAMPLE_23ANDME_V4 = `# rsid	chromosome	position	genotype
rs4477212	1	82154	AA
rs3094315	1	752566	AG
rs3131972	1	752721	AG
rs12562034	1	768448	GG
`;

const SAMPLE_23ANDME_V3 = `# rsid	chromosome	position	genotype
rs4477212	1	82154	TT
rs3094315	1	752566	GG
`;

// ============================================================================
// Sample Data - AncestryDNA Format
// ============================================================================

const SAMPLE_ANCESTRY = `#AncestryDNA raw data download
#This file was generated by AncestryDNA https://dna.ancestry.com
#
#This file contains raw genotype data for your AncestryDNA test.
#
rsid,chromosome,position,allele1,allele2
rs4477212,1,82154,A,A
rs3094315,1,752566,A,G
rs3131972,1,752721,A,G
rs12562034,1,768448,G,G
rs7574865,2,191964633,G,T
rs5746647,22,17057802,C,T
rs9999999,1,123456,0,0
`;

// ============================================================================
// Sample Data - MyHeritage Format
// ============================================================================

const SAMPLE_MYHERITAGE = `"RSID","CHROMOSOME","POSITION","RESULT"
"rs4477212","1","82154","AA"
"rs3094315","1","752566","AG"
"rs3131972","1","752721","AG"
"rs12562034","1","768448","GG"
"rs9999998","2","54321","--"
"rs9999997","3","11111","NC"
`;

// MyHeritage unquoted format - note: this is identical to FTDNA header
// In practice, MyHeritage typically uses quoted CSV format
const SAMPLE_MYHERITAGE_UNQUOTED = `"RSID","CHROMOSOME","POSITION","RESULT"
rs4477212,1,82154,AA
rs3094315,1,752566,AG
rs3131972,1,752721,AG
`;

// ============================================================================
// Sample Data - FamilyTreeDNA Format
// ============================================================================

const SAMPLE_FTDNA = `RSID,CHROMOSOME,POSITION,RESULT
rs4477212,1,82154,AA
rs3094315,1,752566,AG
rs3131972,1,752721,AG
rs12562034,1,768448,GG
rs9999996,4,99999,--
`;

// Note: Quoted FTDNA format is detected as MyHeritage since they share the same format
const SAMPLE_FTDNA_QUOTED = `RSID,CHROMOSOME,POSITION,RESULT
"rs4477212","1","82154","AA"
"rs3094315","1","752566","AG"
`;

// ============================================================================
// Sample Data - LivingDNA Format
// ============================================================================

const SAMPLE_LIVINGDNA = `rsid,chromosome,position,genotype
rs4477212,1,82154,AA
rs3094315,1,752566,AG
rs3131972,1,752721,AG
rs12562034,1,768448,GG
rs9999995,5,55555,--
`;

// ============================================================================
// Sample Data - VCF Format
// ============================================================================

const SAMPLE_VCF = `##fileformat=VCFv4.3
##FILTER=<ID=PASS,Description="All filters passed">
##FORMAT=<ID=GT,Number=1,Type=String,Description="Genotype">
##FORMAT=<ID=DP,Number=1,Type=Integer,Description="Read Depth">
##contig=<ID=1,length=249250621>
##contig=<ID=2,length=243199373>
##reference=GRCh37
#CHROM	POS	ID	REF	ALT	QUAL	FILTER	INFO	FORMAT	SAMPLE1
1	82154	rs4477212	T	A	100	PASS	.	GT:DP	1/1:30
1	752566	rs3094315	A	G	100	PASS	.	GT:DP	0/1:25
1	752721	rs3131972	A	G	100	PASS	.	GT:DP	0/1:28
1	768448	rs12562034	A	G	100	PASS	.	GT:DP	1/1:32
2	191964633	rs7574865	G	T	100	PASS	.	GT:DP	0/1:20
22	17057802	rs5746647	C	T	100	PASS	.	GT:DP	0/1:18
`;

const SAMPLE_VCF_MULTI_SAMPLE = `##fileformat=VCFv4.2
#CHROM	POS	ID	REF	ALT	QUAL	FILTER	INFO	FORMAT	SAMPLE1	SAMPLE2	SAMPLE3
1	82154	rs4477212	T	A	100	PASS	.	GT:DP	1/1:30	0/1:25	0/0:20
`;

// ============================================================================
// Tests - Format Detection
// ============================================================================

describe('Format Detection', () => {
  it('should detect 23andMe v5 format', () => {
    expect(detectFormat(SAMPLE_23ANDME_V5)).toBe('23andme_v5');
  });

  it('should detect 23andMe v4 format', () => {
    // Small sample with minimal headers defaults to v3
    expect(detectFormat(SAMPLE_23ANDME_V4)).toBe('23andme_v3');
  });

  it('should detect AncestryDNA format', () => {
    expect(detectFormat(SAMPLE_ANCESTRY)).toBe('ancestrydna');
  });

  it('should detect MyHeritage format (quoted)', () => {
    expect(detectFormat(SAMPLE_MYHERITAGE)).toBe('myheritage');
  });

  it('should detect MyHeritage format (unquoted)', () => {
    expect(detectFormat(SAMPLE_MYHERITAGE_UNQUOTED)).toBe('myheritage');
  });

  it('should detect FamilyTreeDNA format', () => {
    expect(detectFormat(SAMPLE_FTDNA)).toBe('ftdna');
  });

  it('should detect LivingDNA format', () => {
    expect(detectFormat(SAMPLE_LIVINGDNA)).toBe('livingdna');
  });

  it('should detect VCF format', () => {
    expect(detectFormat(SAMPLE_VCF)).toBe('vcf');
  });

  it('should return unknown for invalid format', () => {
    expect(detectFormat('random garbage data')).toBe('unknown');
    expect(detectFormat('')).toBe('unknown');
  });
});

// ============================================================================
// Tests - Format-specific detectors
// ============================================================================

describe('Format-specific Detectors', () => {
  describe('23andMe', () => {
    it('should detect 23andMe format', () => {
      expect(is23andMeFormat(SAMPLE_23ANDME_V5)).toBe(true);
      expect(is23andMeFormat(SAMPLE_23ANDME_V4)).toBe(true);
    });

    it('should detect 23andMe version', () => {
      expect(detect23andMeVersion(SAMPLE_23ANDME_V5)).toBe('v5');
    });
  });

  describe('AncestryDNA', () => {
    it('should detect AncestryDNA format', () => {
      expect(isAncestryFormat(SAMPLE_ANCESTRY)).toBe(true);
    });

    it('should not detect other formats as AncestryDNA', () => {
      expect(isAncestryFormat(SAMPLE_23ANDME_V5)).toBe(false);
    });
  });

  describe('MyHeritage', () => {
    it('should detect MyHeritage format', () => {
      expect(isMyHeritageFormat(SAMPLE_MYHERITAGE)).toBe(true);
      expect(isMyHeritageFormat(SAMPLE_MYHERITAGE_UNQUOTED)).toBe(true);
    });
  });

  describe('FamilyTreeDNA', () => {
    it('should detect FTDNA format', () => {
      expect(isFTDNAFormat(SAMPLE_FTDNA)).toBe(true);
      // Quoted header also matches
      expect(isFTDNAFormat(SAMPLE_FTDNA_QUOTED)).toBe(true);
    });
  });

  describe('LivingDNA', () => {
    it('should detect LivingDNA format', () => {
      expect(isLivingDNAFormat(SAMPLE_LIVINGDNA)).toBe(true);
    });
  });

  describe('VCF', () => {
    it('should detect VCF format', () => {
      expect(isVCFFormat(SAMPLE_VCF)).toBe(true);
    });

    it('should detect VCF version', () => {
      const version = detectVCFVersion(SAMPLE_VCF);
      expect(version).not.toBeNull();
      expect(version?.major).toBe(4);
      expect(version?.minor).toBe(3);
    });

    it('should get VCF sample names', () => {
      const names = getVCFSampleNames(SAMPLE_VCF);
      expect(names).toEqual(['SAMPLE1']);
    });

    it('should get multiple VCF sample names', () => {
      const names = getVCFSampleNames(SAMPLE_VCF_MULTI_SAMPLE);
      expect(names).toEqual(['SAMPLE1', 'SAMPLE2', 'SAMPLE3']);
    });
  });
});

// ============================================================================
// Tests - Line Parsers
// ============================================================================

describe('Line Parsers', () => {
  describe('23andMe Line Parser', () => {
    it('should parse valid 23andMe line', () => {
      const snp = parse23andMeLine('rs4477212\t1\t82154\tAA');
      expect(snp).not.toBeNull();
      expect(snp?.rsid).toBe('rs4477212');
      expect(snp?.chromosome).toBe('1');
      expect(snp?.position).toBe(82154);
      expect(snp?.genotype).toBe('AA');
      expect(snp?.allele1).toBe('A');
      expect(snp?.allele2).toBe('A');
    });

    it('should parse internal IDs (i-numbers)', () => {
      const snp = parse23andMeLine('i713426\t1\t72017\tCC');
      expect(snp).not.toBeNull();
      expect(snp?.rsid).toBe('i713426');
    });

    it('should parse no-call genotypes', () => {
      const snp = parse23andMeLine('rs123456\t1\t12345\t--');
      expect(snp).not.toBeNull();
      expect(snp?.genotype).toBe('--');
      expect(snp?.allele1).toBe('-');
      expect(snp?.allele2).toBe('-');
    });

    it('should handle X chromosome', () => {
      const snp = parse23andMeLine('rs123456\tX\t12345\tAG');
      expect(snp).not.toBeNull();
      expect(snp?.chromosome).toBe('X');
    });

    it('should handle Y chromosome', () => {
      const snp = parse23andMeLine('rs123456\tY\t12345\tCC');
      expect(snp).not.toBeNull();
      expect(snp?.chromosome).toBe('Y');
    });

    it('should handle MT chromosome', () => {
      const snp = parse23andMeLine('rs123456\tMT\t12345\tGG');
      expect(snp).not.toBeNull();
      expect(snp?.chromosome).toBe('MT');
    });

    it('should normalize chr prefix', () => {
      const snp = parse23andMeLine('rs123456\tchr1\t12345\tAA');
      expect(snp).not.toBeNull();
      expect(snp?.chromosome).toBe('1');
    });

    it('should return null for invalid lines', () => {
      expect(parse23andMeLine('')).toBeNull();
      expect(parse23andMeLine('# comment')).toBeNull();
      expect(parse23andMeLine('invalid')).toBeNull();
      expect(parse23andMeLine('rs123\t1')).toBeNull(); // Too few columns
    });

    it('should return null for invalid rsID format', () => {
      expect(parse23andMeLine('abc123\t1\t12345\tAA')).toBeNull();
    });
  });

  describe('AncestryDNA Line Parser', () => {
    it('should parse valid AncestryDNA line', () => {
      const snp = parseAncestryLine('rs4477212,1,82154,A,A');
      expect(snp).not.toBeNull();
      expect(snp?.rsid).toBe('rs4477212');
      expect(snp?.chromosome).toBe('1');
      expect(snp?.position).toBe(82154);
      expect(snp?.genotype).toBe('AA');
      expect(snp?.allele1).toBe('A');
      expect(snp?.allele2).toBe('A');
    });

    it('should parse heterozygous genotypes', () => {
      const snp = parseAncestryLine('rs3094315,1,752566,A,G');
      expect(snp).not.toBeNull();
      expect(snp?.genotype).toBe('AG');
    });

    it('should handle no-call (0,0)', () => {
      const snp = parseAncestryLine('rs9999999,1,123456,0,0');
      expect(snp).not.toBeNull();
      expect(snp?.genotype).toBe('--');
    });

    it('should return null for header line', () => {
      expect(parseAncestryLine('rsid,chromosome,position,allele1,allele2')).toBeNull();
    });
  });

  describe('MyHeritage Line Parser', () => {
    it('should parse quoted MyHeritage line', () => {
      const snp = parseMyHeritageLine('"rs4477212","1","82154","AA"');
      expect(snp).not.toBeNull();
      expect(snp?.rsid).toBe('rs4477212');
      expect(snp?.genotype).toBe('AA');
    });

    it('should parse unquoted MyHeritage line', () => {
      const snp = parseMyHeritageLine('rs4477212,1,82154,AG');
      expect(snp).not.toBeNull();
      expect(snp?.genotype).toBe('AG');
    });

    it('should handle NC (no-call) genotype', () => {
      const snp = parseMyHeritageLine('"rs9999997","3","11111","NC"');
      expect(snp).not.toBeNull();
      expect(snp?.genotype).toBe('--');
    });
  });

  describe('FamilyTreeDNA Line Parser', () => {
    it('should parse valid FTDNA line', () => {
      const snp = parseFTDNALine('rs4477212,1,82154,AA');
      expect(snp).not.toBeNull();
      expect(snp?.rsid).toBe('rs4477212');
      expect(snp?.genotype).toBe('AA');
    });

    it('should parse quoted FTDNA line', () => {
      const snp = parseFTDNALine('"rs4477212","1","82154","AG"');
      expect(snp).not.toBeNull();
      expect(snp?.genotype).toBe('AG');
    });
  });

  describe('LivingDNA Line Parser', () => {
    it('should parse valid LivingDNA line', () => {
      const snp = parseLivingDNALine('rs4477212,1,82154,AA');
      expect(snp).not.toBeNull();
      expect(snp?.rsid).toBe('rs4477212');
      expect(snp?.genotype).toBe('AA');
    });
  });

  describe('VCF Line Parser', () => {
    it('should parse valid VCF line', () => {
      const snp = parseVCFLine('1\t82154\trs4477212\tT\tA\t100\tPASS\t.\tGT:DP\t1/1:30');
      expect(snp).not.toBeNull();
      expect(snp?.rsid).toBe('rs4477212');
      expect(snp?.chromosome).toBe('1');
      expect(snp?.position).toBe(82154);
      expect(snp?.genotype).toBe('AA');
    });

    it('should parse heterozygous VCF line', () => {
      const snp = parseVCFLine('1\t752566\trs3094315\tA\tG\t100\tPASS\t.\tGT:DP\t0/1:25');
      expect(snp).not.toBeNull();
      expect(snp?.genotype).toBe('AG');
    });

    it('should parse phased genotype', () => {
      const snp = parseVCFLine('1\t12345\trs123\tA\tG\t100\tPASS\t.\tGT\t0|1');
      expect(snp).not.toBeNull();
      expect(snp?.genotype).toBe('AG');
    });

    it('should handle missing rsID', () => {
      const snp = parseVCFLine('1\t12345\t.\tA\tG\t100\tPASS\t.\tGT\t0/1');
      expect(snp).not.toBeNull();
      expect(snp?.rsid).toBe('chr1:12345');
    });

    it('should handle missing genotype', () => {
      const snp = parseVCFLine('1\t12345\trs123\tA\tG\t100\tPASS\t.\tGT\t.');
      expect(snp).not.toBeNull();
      expect(snp?.genotype).toBe('--');
    });
  });
});

// ============================================================================
// Tests - Utility Functions
// ============================================================================

describe('Utility Functions', () => {
  describe('normalizeChromosome', () => {
    it('should normalize standard chromosomes', () => {
      expect(normalizeChromosome('1')).toBe('1');
      expect(normalizeChromosome('22')).toBe('22');
      expect(normalizeChromosome('X')).toBe('X');
      expect(normalizeChromosome('Y')).toBe('Y');
    });

    it('should remove chr prefix', () => {
      expect(normalizeChromosome('chr1')).toBe('1');
      expect(normalizeChromosome('Chr22')).toBe('22');
      expect(normalizeChromosome('chrX')).toBe('X');
      expect(normalizeChromosome('CHRM')).toBe('MT');
    });

    it('should normalize mitochondrial', () => {
      expect(normalizeChromosome('M')).toBe('MT');
      expect(normalizeChromosome('MT')).toBe('MT');
      expect(normalizeChromosome('chrM')).toBe('MT');
    });

    it('should return null for invalid chromosomes', () => {
      expect(normalizeChromosome('')).toBeNull();
      expect(normalizeChromosome('23')).toBeNull();
      expect(normalizeChromosome('invalid')).toBeNull();
    });
  });

  describe('validateGenotype', () => {
    it('should validate standard genotypes', () => {
      expect(validateGenotype('AA')).toBe(true);
      expect(validateGenotype('AG')).toBe(true);
      expect(validateGenotype('CT')).toBe(true);
      expect(validateGenotype('GG')).toBe(true);
    });

    it('should validate no-call genotypes', () => {
      expect(validateGenotype('--')).toBe(true);
      expect(validateGenotype('00')).toBe(true);
    });

    it('should validate indel markers', () => {
      expect(validateGenotype('II')).toBe(true);
      expect(validateGenotype('DD')).toBe(true);
      expect(validateGenotype('ID')).toBe(true);
    });

    it('should reject invalid genotypes', () => {
      expect(validateGenotype('')).toBe(false);
      expect(validateGenotype('A')).toBe(false);
      expect(validateGenotype('AAA')).toBe(false);
      expect(validateGenotype('XY')).toBe(false);
    });
  });

  describe('isValidRsid', () => {
    it('should validate standard rsIDs', () => {
      expect(isValidRsid('rs123456')).toBe(true);
      expect(isValidRsid('rs1')).toBe(true);
      expect(isValidRsid('rs999999999')).toBe(true);
    });

    it('should validate internal IDs', () => {
      expect(isValidRsid('i123456')).toBe(true);
      expect(isValidRsid('i1')).toBe(true);
    });

    it('should reject invalid rsIDs', () => {
      expect(isValidRsid('')).toBe(false);
      expect(isValidRsid('123456')).toBe(false);
      expect(isValidRsid('abc123')).toBe(false);
      expect(isValidRsid('rs')).toBe(false);
    });
  });
});

// ============================================================================
// Tests - Full File Parsing
// ============================================================================

describe('Full File Parsing', () => {
  it('should parse 23andMe v5 file', async () => {
    const result = await parseGenomeFile(SAMPLE_23ANDME_V5);

    expect(result.format).toBe('23andme_v5');
    expect(result.snpCount).toBeGreaterThan(0);
    expect(result.snps.size).toBe(result.snpCount);
    // Note: validation.valid may be false due to small test sample (MIN_SNPS_THRESHOLD)
    // In production, files have 500k+ SNPs
    expect(result.validation.errors.filter(e => e.fatal)).toHaveLength(0);
    expect(result.metadata.source).toBe('23andMe');
  });

  it('should parse AncestryDNA file', async () => {
    const result = await parseGenomeFile(SAMPLE_ANCESTRY);

    expect(result.format).toBe('ancestrydna');
    expect(result.snpCount).toBeGreaterThan(0);
    expect(result.metadata.source).toBe('AncestryDNA');
  });

  it('should parse MyHeritage file', async () => {
    const result = await parseGenomeFile(SAMPLE_MYHERITAGE);

    expect(result.format).toBe('myheritage');
    expect(result.snpCount).toBeGreaterThan(0);
    expect(result.metadata.source).toBe('MyHeritage');
  });

  it('should parse FamilyTreeDNA file', async () => {
    const result = await parseGenomeFile(SAMPLE_FTDNA);

    expect(result.format).toBe('ftdna');
    expect(result.snpCount).toBeGreaterThan(0);
    expect(result.metadata.source).toBe('FamilyTreeDNA');
  });

  it('should parse LivingDNA file', async () => {
    const result = await parseGenomeFile(SAMPLE_LIVINGDNA);

    expect(result.format).toBe('livingdna');
    expect(result.snpCount).toBeGreaterThan(0);
    expect(result.metadata.source).toBe('LivingDNA');
  });

  it('should parse VCF file', async () => {
    const result = await parseGenomeFile(SAMPLE_VCF);

    expect(result.format).toBe('vcf');
    expect(result.snpCount).toBeGreaterThan(0);
    expect(result.metadata.source).toBe('VCF');
  });

  it('should track progress during parsing', async () => {
    const progressUpdates: Array<{ phase: string; percentComplete: number }> = [];

    await parseGenomeFile(SAMPLE_23ANDME_V5, {
      onProgress: (progress) => {
        progressUpdates.push({
          phase: progress.phase,
          percentComplete: progress.percentComplete
        });
      }
    });

    expect(progressUpdates.length).toBeGreaterThan(0);
    expect(progressUpdates[0].phase).toBe('detecting');
    expect(progressUpdates[progressUpdates.length - 1].phase).toBe('complete');
    expect(progressUpdates[progressUpdates.length - 1].percentComplete).toBe(100);
  });

  it('should throw error for unknown format', async () => {
    await expect(parseGenomeFile('random garbage data')).rejects.toThrow(GenomeParseError);
  });

  it('should handle duplicate rsIDs with warnings', async () => {
    const dataWithDuplicates = `# rsid	chromosome	position	genotype
rs4477212	1	82154	AA
rs4477212	1	82154	AG
rs3094315	1	752566	CC
`;

    const result = await parseGenomeFile(dataWithDuplicates);

    // Should only have 2 unique SNPs (first occurrence kept)
    expect(result.snpCount).toBe(2);

    // Should have warning about duplicate
    const duplicateWarning = result.validation.warnings.find(w => w.code === 'DUPLICATE_RSID');
    expect(duplicateWarning).toBeDefined();
    expect(duplicateWarning?.rsid).toBe('rs4477212');
  });

  it('should skip invalid lines with warnings', async () => {
    const dataWithInvalid = `# rsid	chromosome	position	genotype
rs4477212	1	82154	AA
invalid_line_here
rs3094315	1	752566	CC
`;

    const result = await parseGenomeFile(dataWithInvalid, { skipInvalidLines: true });

    expect(result.snpCount).toBe(2);
    expect(result.validation.snpsSkipped).toBeGreaterThan(0);
  });

  it('should generate unique IDs', async () => {
    const result1 = await parseGenomeFile(SAMPLE_23ANDME_V5);
    const result2 = await parseGenomeFile(SAMPLE_23ANDME_V5);

    expect(result1.id).not.toBe(result2.id);
  });
});

// ============================================================================
// Tests - Build Detection
// ============================================================================

describe('Build Detection', () => {
  it('should detect GRCh37 build from 23andMe v5 sample', async () => {
    const result = await parseGenomeFile(SAMPLE_23ANDME_V5);

    // The sample data uses GRCh37 positions
    expect(result.build).toBe('GRCh37');
    expect(result.buildConfidence).toBeGreaterThan(0.5);
  });

  it('should return unknown for insufficient reference SNPs', () => {
    const snps = new Map<string, SNP>();
    snps.set('rs999999', {
      rsid: 'rs999999',
      chromosome: '1',
      position: 12345,
      genotype: 'AA',
      allele1: 'A',
      allele2: 'A'
    });

    const result = detectBuild(snps);
    expect(result.build).toBe('unknown');
    expect(result.totalChecked).toBe(0);
  });
});

// ============================================================================
// Tests - Statistics Functions
// ============================================================================

describe('Statistics Functions', () => {
  let testSnps: Map<string, SNP>;

  beforeEach(() => {
    testSnps = new Map<string, SNP>();
    testSnps.set('rs1', {
      rsid: 'rs1',
      chromosome: '1',
      position: 100,
      genotype: 'AA',
      allele1: 'A',
      allele2: 'A'
    });
    testSnps.set('rs2', {
      rsid: 'rs2',
      chromosome: '1',
      position: 200,
      genotype: 'AG',
      allele1: 'A',
      allele2: 'G'
    });
    testSnps.set('rs3', {
      rsid: 'rs3',
      chromosome: '2',
      position: 300,
      genotype: '--',
      allele1: '-',
      allele2: '-'
    });
    testSnps.set('rs4', {
      rsid: 'rs4',
      chromosome: '2',
      position: 400,
      genotype: 'CC',
      allele1: 'C',
      allele2: 'C'
    });
  });

  describe('getChromosomeCounts', () => {
    it('should count SNPs by chromosome', () => {
      const counts = getChromosomeCounts(testSnps);
      expect(counts['1']).toBe(2);
      expect(counts['2']).toBe(2);
    });
  });

  describe('getNoCallRate', () => {
    it('should calculate no-call rate', () => {
      const rate = getNoCallRate(testSnps);
      expect(rate).toBe(0.25); // 1 out of 4
    });

    it('should return 0 for empty map', () => {
      expect(getNoCallRate(new Map())).toBe(0);
    });
  });

  describe('getHeterozygosityRate', () => {
    it('should calculate heterozygosity rate', () => {
      const rate = getHeterozygosityRate(testSnps);
      // 1 het (rs2) out of 3 valid genotypes (excluding no-call)
      expect(rate).toBeCloseTo(0.333, 2);
    });

    it('should return 0 for empty map', () => {
      expect(getHeterozygosityRate(new Map())).toBe(0);
    });
  });
});

// ============================================================================
// Tests - Edge Cases
// ============================================================================

describe('Edge Cases', () => {
  it('should handle empty file', async () => {
    await expect(parseGenomeFile('')).rejects.toThrow();
  });

  it('should handle file with only comments', async () => {
    const data = `# comment 1
# comment 2
# comment 3
`;
    await expect(parseGenomeFile(data)).rejects.toThrow();
  });

  it('should handle Windows line endings', async () => {
    const data = `# rsid\tchromosome\tposition\tgenotype\r
rs4477212\t1\t82154\tAA\r
rs3094315\t1\t752566\tAG\r
`;
    const result = await parseGenomeFile(data);
    expect(result.snpCount).toBe(2);
  });

  it('should handle mixed case genotypes', async () => {
    const data = `# rsid	chromosome	position	genotype
rs4477212	1	82154	aa
rs3094315	1	752566	Ag
rs3131972	1	752721	aG
`;
    const result = await parseGenomeFile(data);
    expect(result.snpCount).toBe(3);

    const snp = result.snps.get('rs4477212');
    expect(snp?.genotype).toBe('AA');
  });

  it('should handle extra whitespace', async () => {
    const data = `# rsid	chromosome	position	genotype
rs4477212	 1 	 82154 	 AA
rs3094315	1	752566	AG
`;
    const result = await parseGenomeFile(data);
    expect(result.snpCount).toBe(2);
  });

  it('should track file metadata', async () => {
    const result = await parseGenomeFile(SAMPLE_23ANDME_V5);

    expect(result.metadata.rawFileSize).toBe(SAMPLE_23ANDME_V5.length);
    expect(result.fileName).toBe('pasted_content');
    expect(result.parsedAt).toBeInstanceOf(Date);
  });
});
